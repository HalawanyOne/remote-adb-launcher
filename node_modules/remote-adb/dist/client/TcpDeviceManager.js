"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TcpDeviceManager = void 0;
const events_1 = __importDefault(require("events"));
const net = __importStar(require("net"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs/promises"));
const AdbTcpTransport_1 = require("./AdbTcpTransport");
const RemoteAdbDevice_1 = require("./RemoteAdbDevice");
const EMULATOR_DEFAULT_PORT = 5555;
const EMULATOR_MAX_PORT = 5585;
const EMULATOR_HOST = "127.0.0.1";
const REFRESH_LOOP_TIMEOUT = 5000;
class TcpDeviceManagerSingleton {
    constructor() {
        this.events = new events_1.default();
        this.connectedDevices = new Map();
        this.connectedEmulators = new Map();
        this.refreshEmulatorsLoop = () => __awaiter(this, void 0, void 0, function* () {
            clearTimeout(this.refreshLoopTimeout);
            yield this.refreshEmulators();
            this.refreshLoopTimeout = setTimeout(this.refreshEmulatorsLoop, REFRESH_LOOP_TIMEOUT);
        });
        this.notifyDevicesRefreshed = () => __awaiter(this, void 0, void 0, function* () {
            const devices = Array.from(this.connectedDevices.values()).concat(Array.from(this.connectedEmulators.values()));
            this.events.emit("devices", devices);
        });
    }
    isSupported() {
        return true;
    }
    createDevice(serial) {
        return __awaiter(this, void 0, void 0, function* () {
            let device = yield this.getOrCreateTcpDevice(serial);
            if (device) {
                this.connectedDevices.set(serial, device);
                this.connectedEmulators.delete(serial);
                this.notifyDevicesRefreshed();
            }
            return device;
        });
    }
    removeDevice(serial) {
        return __awaiter(this, void 0, void 0, function* () {
            let device = this.connectedDevices.get(serial);
            if (device === null || device === void 0 ? void 0 : device.connected) {
                yield device.disconnect();
            }
            if (this.connectedDevices.delete(serial)) {
                this.notifyDevicesRefreshed();
            }
        });
    }
    canRemoveDevice(serial) {
        return this.connectedDevices.has(serial);
    }
    getOrCreateTcpDevice(serial) {
        return __awaiter(this, void 0, void 0, function* () {
            let device = this.connectedDevices.get(serial) || this.connectedEmulators.get(serial);
            if (!device) {
                device = yield this.createTcpDevice(serial);
            }
            return device;
        });
    }
    createTcpDevice(serial) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let host;
                let port;
                let name;
                if (serial.startsWith("emulator-")) {
                    let consolePort = Number(serial.replace(/^emulator-/, ""));
                    if (Number.isNaN(consolePort)) {
                        return;
                    }
                    host = EMULATOR_HOST;
                    port = consolePort + 1;
                    name = yield this.getEmulatorName(consolePort);
                }
                else {
                    const url = new URL(`tcp://${serial}`);
                    if (!url.hostname || !url.port || Number.isNaN(Number(url.port))
                        || url.pathname || url.search || url.hash || url.username || url.password) {
                        return;
                    }
                    host = url.hostname;
                    port = Number(url.port);
                    serial = `${host}:${port}`;
                }
                const device = new RemoteAdbDevice_1.RemoteAdbDevice(new AdbTcpTransport_1.AdbTcpTransport(serial, name, host, port));
                device.on("connected", this.notifyDevicesRefreshed);
                device.on("disconnected", this.notifyDevicesRefreshed);
                return device;
            }
            catch (_a) {
                return;
            }
        });
    }
    canConnectToSocket(host, port) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise((resolve, reject) => {
                const socket = net.connect({
                    host,
                    port
                }, () => {
                    resolve();
                    socket.end();
                });
                socket.once("error", (e) => {
                    reject(e);
                });
            });
        });
    }
    getEmulatorConsoleToken() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const tokenFilePath = path.join(os.homedir(), ".emulator_console_auth_token");
                const token = yield fs.readFile(tokenFilePath, { encoding: "utf8" });
                return token.trim();
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    getEmulatorName(consolePort) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let responsesToSkip = 1;
                const socket = net.connect({
                    host: EMULATOR_HOST,
                    port: consolePort,
                }, () => __awaiter(this, void 0, void 0, function* () {
                    let command = "";
                    const token = yield this.getEmulatorConsoleToken();
                    if (token) {
                        command += `auth ${token}\n`;
                        responsesToSkip += 1;
                    }
                    command += "avd name\n";
                    command += "quit\n";
                    socket.write(command);
                }));
                let output = "";
                socket.on("data", (data) => {
                    output += data.toString("utf8");
                });
                socket.on("end", () => {
                    let responses = output.split("OK\r\n");
                    if (responses.length === (responsesToSkip + 2)) {
                        let name = responses[responsesToSkip].trim().replace(/_/g, " ");
                        resolve(name);
                    }
                    else {
                        resolve(undefined);
                    }
                });
                socket.on("error", (e) => {
                    resolve(undefined);
                });
            });
        });
    }
    refreshEmulators() {
        return __awaiter(this, void 0, void 0, function* () {
            let ports = [];
            for (let port = EMULATOR_DEFAULT_PORT; port <= EMULATOR_MAX_PORT; port += 2) {
                ports.push(port);
            }
            let availablePorts = [];
            (yield Promise.allSettled(ports.map(p => this.canConnectToSocket(EMULATOR_HOST, p)))).forEach((s, index) => {
                if (s.status == "fulfilled") {
                    availablePorts.push(ports[index]);
                }
            });
            const serials = availablePorts.map(p => `emulator-${p - 1}`);
            const serialsSet = new Set(serials);
            if (
            // If every available serial is already seen before
            serials.every(serial => this.connectedDevices.has(serial) || this.connectedEmulators.has(serial))
                // And every emulator is still available
                && Array.from(this.connectedEmulators.keys()).every(serial => serialsSet.has(serial))) {
                // No update is needed.
                return;
            }
            let devices = yield Promise.all(serials.map(serial => this.getOrCreateTcpDevice(serial)));
            this.connectedEmulators = new Map();
            devices.forEach(device => {
                // Skip adding if the emulator is also manually added
                if (!this.connectedDevices.has(device.serial)) {
                    this.connectedEmulators.set(device.serial, device);
                }
            });
            this.notifyDevicesRefreshed();
        });
    }
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refreshEmulators();
            return Array.from(this.connectedDevices.values()).concat(Array.from(this.connectedEmulators.values()));
        });
    }
    monitorDevices(callback) {
        this.events.on('devices', callback);
        this.notifyDevicesRefreshed();
        this.refreshEmulatorsLoop();
    }
}
exports.TcpDeviceManager = new TcpDeviceManagerSingleton();
//# sourceMappingURL=TcpDeviceManager.js.map