"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteAdbDevice = void 0;
const events_1 = require("events");
const logger_1 = __importDefault(require("../common/logger"));
const ServerConnection_1 = require("./ServerConnection");
const handshake_1 = require("../common/handshake");
class RemoteAdbDevice extends events_1.EventEmitter {
    get serial() {
        return this.backend.serial;
    }
    get name() {
        return this.backend.name;
    }
    get remoteSerial() {
        var _a;
        return (_a = this.serverHandshake) === null || _a === void 0 ? void 0 : _a.serial;
    }
    get bytesTransferred() {
        return this.backend.bytesTransferred;
    }
    constructor(backend) {
        super();
        this._connecting = false;
        this.connect = (serverConnection) => __awaiter(this, void 0, void 0, function* () {
            this._connecting = true;
            try {
                // Connect with the backend
                yield this.backend.connect();
                logger_1.default.log(this.backend.serial, `${this.backend.type} connected`);
                this.backend.ondisconnect(() => {
                    logger_1.default.log(this.backend.serial, `${this.backend.type} closed. Closing WebSocket.`);
                    this.disconnectWebSocket(true);
                });
                // Connect to WebSocket
                this.ws = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    const ws = yield serverConnection.createWebSocket("");
                    ws.binaryType = "arraybuffer";
                    let resolved = false;
                    ws.onopen = () => {
                        resolved = true;
                        resolve(ws);
                    };
                    ws.onerror = () => { }; // This is required in node to not crash on error
                    ws.onclose = () => {
                        if (!resolved) {
                            reject(new Error("Error connecting to WebSocket"));
                        }
                    };
                })).catch((e) => __awaiter(this, void 0, void 0, function* () {
                    yield this.disconnectBackend(false);
                    throw e;
                }));
                this.ws.onerror = (e) => {
                    logger_1.default.log(this.backend.serial, `WebSocket error: ${e}`);
                };
                this.ws.onclose = (e) => {
                    logger_1.default.log(this.backend.serial, `WebSocket closed (code: ${e.code}${e.reason ? `, reason: ${e.reason}` : ""}). Closing device.`);
                    this.disconnectBackend(true);
                };
                logger_1.default.log(this.backend.serial, "WebSocket connected. Waiting for handshake...");
                // Send handshake data
                const handshakeData = {
                    type: "handshake",
                    name: this.name,
                    serial: this.serial
                };
                this.ws.send(JSON.stringify(handshakeData));
                // Wait for the handshake response
                this.serverHandshake = yield (0, handshake_1.getRemoteHandshake)(this.ws);
                logger_1.default.log(this.backend.serial, `Connected as ${this.remoteSerial}`);
                yield this.backend.pipe(this.ws);
                this.emit("connected", this);
            }
            catch (e) {
                logger_1.default.log(this.backend.serial, `Error connecting: ${e.message}`);
                yield this.disconnectBackend(false);
                yield this.disconnectWebSocket(false);
                throw e;
            }
            finally {
                this._connecting = false;
            }
        });
        this.disconnectBackend = (emit) => __awaiter(this, void 0, void 0, function* () {
            yield this.backend.dispose();
            logger_1.default.log(this.backend.serial, `${this.backend.type} closed`);
            if (emit) {
                this.emit("disconnected", this);
            }
        });
        this.disconnectWebSocket = (emit) => __awaiter(this, void 0, void 0, function* () {
            if (!this.ws) {
                return;
            }
            this.ws.onclose = undefined;
            this.ws.close();
            logger_1.default.log(this.backend.serial, `WebSocket closed`);
            if (emit) {
                this.emit("disconnected", this);
            }
        });
        this.disconnect = () => __awaiter(this, void 0, void 0, function* () {
            yield this.disconnectBackend(false);
            yield this.disconnectWebSocket(false);
            this.emit("disconnected", this);
        });
        this.backend = backend;
    }
    get connected() {
        var _a;
        return this.backend.connected && ((_a = this.ws) === null || _a === void 0 ? void 0 : _a.readyState) == ServerConnection_1.WebSocket.OPEN && !this._connecting;
    }
    get connecting() {
        return this._connecting;
    }
}
exports.RemoteAdbDevice = RemoteAdbDevice;
//# sourceMappingURL=RemoteAdbDevice.js.map