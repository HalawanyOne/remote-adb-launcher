"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdbTcpTransport = void 0;
const events_1 = require("events");
const net_1 = require("net");
const stream_1 = require("stream");
const ws_1 = require("ws");
const AdbTransportProtocolHandler_1 = __importDefault(require("./AdbTransportProtocolHandler"));
// Works only in node, not in browser
// Takes in ArrayBuffer and converts it to Buffer for the remaining pipeline to consume
class ConvertToBuffer extends stream_1.Transform {
    constructor(opts) {
        super(Object.assign(Object.assign({}, opts), { writableObjectMode: true }));
    }
    _transform(chunk, encoding, callback) {
        this.push(Buffer.from(chunk));
        callback();
    }
}
// Logger for the adb communication, parses and logs the incoming data.
// Does nothing otherwise, the incoming stream is passed through.
class AdbCommunicationLogger extends stream_1.Transform {
    constructor(loggerConfig, opts) {
        super(opts);
        this.dataEventHandler = AdbTransportProtocolHandler_1.default.createDataEventHandler(() => __awaiter(this, void 0, void 0, function* () { }), loggerConfig);
    }
    _transform(chunk, encoding, callback) {
        this.dataEventHandler(chunk.buffer);
        this.push(chunk);
        callback();
    }
}
class BytesCounter extends stream_1.Transform {
    constructor(add) {
        super();
        this.add = add;
    }
    _transform(chunk, encoding, callback) {
        this.add(chunk.byteLength);
        this.push(chunk);
        callback();
    }
}
class AdbTcpTransport {
    get serial() { return this._serial; }
    get name() { return this._name || this.serial; }
    get connected() { return this._connected; }
    get bytesTransferred() { return this._bytesTransferred; }
    constructor(serial, name, host, port) {
        this.type = "TCP";
        this._connected = false;
        this._bytesTransferred = {
            up: 0,
            down: 0,
        };
        this.events = new events_1.EventEmitter();
        this.ondisconnect = (listener) => this.events.addListener('disconnect', listener);
        this.handleClose = (hadError) => {
            this._connected = false;
            this.events.emit('disconnect');
        };
        this._serial = serial;
        this._name = name;
        this.host = host;
        this.port = port;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.socket = yield new Promise((resolve, reject) => {
                let resolved = false;
                const socket = new net_1.Socket();
                socket.once('error', (e) => {
                    if (!resolved) {
                        reject(e);
                    }
                });
                socket.once("connect", () => {
                    resolved = true;
                    resolve(socket);
                });
                socket.connect(this.port, this.host);
            });
            this.socket.on("close", this.handleClose);
            this._connected = true;
        });
    }
    pipe(ws) {
        return __awaiter(this, void 0, void 0, function* () {
            // Our ws uses binaryType arraybuffer, which does not work with streams.
            // Set readableObjectMode to true and convert the arraybuffer to buffer in the pipe.
            const wsStream = (0, ws_1.createWebSocketStream)(ws, {
                readableObjectMode: true,
            });
            wsStream
                .pipe(new ConvertToBuffer())
                .pipe(new AdbCommunicationLogger({ tag: this.serial, direction: "<==" }))
                .pipe(new BytesCounter((bytes) => { this._bytesTransferred.down += bytes; }))
                .pipe(this.socket)
                .pipe(new AdbCommunicationLogger({ tag: this.serial, direction: "==>" }))
                .pipe(new BytesCounter((bytes) => { this._bytesTransferred.up += bytes; }))
                .pipe(wsStream, { end: false });
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            this._connected = false;
            this.socket.off("close", this.handleClose);
            this.events.removeAllListeners();
            return new Promise((resolve, reject) => {
                this.socket.end(resolve);
            });
        });
    }
}
exports.AdbTcpTransport = AdbTcpTransport;
//# sourceMappingURL=AdbTcpTransport.js.map