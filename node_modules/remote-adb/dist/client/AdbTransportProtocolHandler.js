"use strict";
// This class knows and handles ADB Transport protocol.
// Details: https://android.googlesource.com/platform/packages/modules/adb/+/master/protocol.txt
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdbTransportProtocolHandler = void 0;
const logger_1 = __importDefault(require("../common/logger"));
class AdbTransportProtocolHandler {
    static getPayloadLength(headerBuffer) {
        // Get the fourth 32 bit integer from the header. This is the payload length
        let header = new DataView(headerBuffer);
        return header.getUint32(12 /* byteOffset */, true /* littleEndian */);
    }
    static concatBuffers(b1, b2) {
        let tmp = new Uint8Array(b1.byteLength + b2.byteLength);
        tmp.set(new Uint8Array(b1), 0);
        tmp.set(new Uint8Array(b2), b1.byteLength);
        return tmp.buffer;
    }
    // Starts the read-write loop for piping adb transport.
    // Useful when input data can be read on demand.
    static startPullPushLoop(isConnected, pull, push, loggerConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                do {
                    // Read header
                    let buffer = yield pull(24);
                    // If we don't get required data, chances are connection is gone
                    // Ignore and try again
                    while (buffer.byteLength !== 24) {
                        continue;
                    }
                    yield push(buffer); // Push header
                    let payload_length = this.getPayloadLength(buffer);
                    logger_1.default.log(loggerConfig.tag, loggerConfig.direction, "header", payload_length);
                    // Read payload as well
                    while (payload_length > 0) {
                        buffer = yield pull(payload_length);
                        yield push(buffer);
                        logger_1.default.log(loggerConfig.tag, loggerConfig.direction, `payload ${payload_length} bytes`);
                        payload_length -= buffer.byteLength;
                    }
                } while (isConnected());
            }
            catch (e) {
                logger_1.default.error(loggerConfig.tag, e);
            }
            return;
        });
    }
    // Returns a function which takes data and calls push for each header and payload as and when available for piping the adb transport.
    // This is useful and input data is available in form of "data" or "message" callbacks, instead of on demand.
    static createDataEventHandler(push, loggerConfig) {
        const AWAITING_HEADER = "AWAITING_HEADER";
        const AWAITING_PAYLOAD = "AWAITING_PAYLOAD";
        let state = AWAITING_HEADER;
        let pending_data = new ArrayBuffer(0);
        let payload_length = 0;
        let lastPromise = Promise.resolve();
        let handleWriteData = (data) => __awaiter(this, void 0, void 0, function* () {
            if (pending_data.byteLength > 0) {
                data = this.concatBuffers(pending_data, data);
                pending_data = new ArrayBuffer(0);
            }
            switch (state) {
                case AWAITING_HEADER:
                    if (data.byteLength < 24) {
                        pending_data = data;
                        logger_1.default.log(`Was expecting 24 bytes, but got ${data.byteLength} bytes. Waiting for more data`);
                    }
                    else {
                        let buffer = data.slice(0, 24);
                        yield push(buffer);
                        // let packetHeader = await parsePacketHeader(buffer, backend);
                        payload_length = this.getPayloadLength(buffer); //packetHeader.payloadLength;
                        logger_1.default.log(loggerConfig.tag, loggerConfig.direction, "header", payload_length);
                        if (payload_length > 0) {
                            state = AWAITING_PAYLOAD;
                        }
                        if (data.byteLength > 24) {
                            yield handleWriteData(data.slice(24));
                        }
                    }
                    break;
                case AWAITING_PAYLOAD:
                    if (data.byteLength > payload_length) {
                        let boundry = payload_length;
                        yield handleWriteData(data.slice(0, boundry));
                        yield handleWriteData(data.slice(boundry));
                    }
                    else {
                        yield push(data);
                        logger_1.default.log(loggerConfig.tag, loggerConfig.direction, `payload ${payload_length} bytes`);
                        payload_length -= data.byteLength;
                        if (payload_length == 0) {
                            state = AWAITING_HEADER;
                            // Sometimes we stop recieving read data after a large transfer.
                            // Writing something seems to resume the communication.
                            // Writing a zero length buffer here as a workaround, not sure if this is expected.
                            yield push(new Uint8Array().buffer);
                        }
                    }
                    break;
            }
        });
        return (data) => {
            lastPromise = lastPromise.then(() => __awaiter(this, void 0, void 0, function* () { yield handleWriteData(data); }));
        };
    }
}
exports.AdbTransportProtocolHandler = AdbTransportProtocolHandler;
exports.default = AdbTransportProtocolHandler;
//# sourceMappingURL=AdbTransportProtocolHandler.js.map