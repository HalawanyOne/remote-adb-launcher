"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdbWebUsbTransport = exports.WebUsbDeviceFilter = void 0;
const events_1 = require("events");
const logger_1 = __importDefault(require("../common/logger"));
const AdbTransportProtocolHandler_1 = __importDefault(require("./AdbTransportProtocolHandler"));
exports.WebUsbDeviceFilter = {
    classCode: 0xFF,
    subclassCode: 0x42,
    protocolCode: 1,
};
// Adopted from https://github.com/yume-chan/ya-webadb/blob/v0.0.9/packages/adb-backend-webusb/src/backend.ts
class AdbWebUsbTransport {
    get serial() { return this._device.serialNumber; }
    get name() { return this._device.productName; }
    get connected() { return this._connected; }
    get bytesTransferred() { return this._bytesTransferred; }
    constructor(usb, device) {
        this.type = "USB";
        this._connected = false;
        this._bytesTransferred = {
            up: 0,
            down: 0,
        };
        this.events = new events_1.EventEmitter();
        this.ondisconnect = (listener) => this.events.addListener('disconnect', listener);
        this.handleDisconnect = (e) => {
            if (typeof e === "undefined" || e.device === this._device) {
                this._connected = false;
                this.events.emit('disconnect');
            }
        };
        this._usb = usb;
        this._device = device;
        this._usb.addEventListener('disconnect', this.handleDisconnect);
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this._device.opened) {
                yield this._device.open();
            }
            for (const configuration of this._device.configurations) {
                for (const interface_ of configuration.interfaces) {
                    for (const alternate of interface_.alternates) {
                        if (alternate.interfaceSubclass === exports.WebUsbDeviceFilter.subclassCode &&
                            alternate.interfaceClass === exports.WebUsbDeviceFilter.classCode &&
                            alternate.interfaceProtocol === exports.WebUsbDeviceFilter.protocolCode) {
                            if (((_a = this._device.configuration) === null || _a === void 0 ? void 0 : _a.configurationValue) !== configuration.configurationValue) {
                                yield this._device.selectConfiguration(configuration.configurationValue);
                            }
                            if (!interface_.claimed) {
                                yield this._device.claimInterface(interface_.interfaceNumber);
                            }
                            if (interface_.alternate.alternateSetting !== alternate.alternateSetting) {
                                yield this._device.selectAlternateInterface(interface_.interfaceNumber, alternate.alternateSetting);
                            }
                            for (const endpoint of alternate.endpoints) {
                                switch (endpoint.direction) {
                                    case 'in':
                                        this._inEndpointNumber = endpoint.endpointNumber;
                                        if (this._outEndpointNumber !== undefined) {
                                            this._connected = true;
                                            return;
                                        }
                                        break;
                                    case 'out':
                                        this._outEndpointNumber = endpoint.endpointNumber;
                                        if (this._inEndpointNumber !== undefined) {
                                            this._connected = true;
                                            return;
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            throw new Error('Unknown error while connecting to WebUsb device.');
        });
    }
    write(buffer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._device.transferOut(this._outEndpointNumber, buffer);
        });
    }
    read(length) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._device.transferIn(this._inEndpointNumber, length);
            if (result.status === 'stall') {
                yield this._device.clearHalt('in', this._inEndpointNumber);
            }
            const { buffer } = result.data;
            return buffer;
        });
    }
    wsSendOrIgnore(ws, buffer, logTag) {
        // We sometimes need to ignore stale data coming from usb before the connection is initialized from the adb server.
        if (ws.readyState !== ws.OPEN) {
            logger_1.default.warn(logTag, "WebSocket is not open. Ignoring sent data");
            return;
        }
        ws.send(buffer);
        this._bytesTransferred.up += buffer.byteLength;
    }
    backendWriteOrIgnore(backend, buffer, logTag) {
        return __awaiter(this, void 0, void 0, function* () {
            // We sometimes need to ignore stale data coming from usb before the connection is initialized from the adb server.
            if (!backend.connected) {
                logger_1.default.warn(logTag, "Device is not connected. Ignoring sent data");
                return;
            }
            yield backend.write(buffer);
            this._bytesTransferred.down += buffer.byteLength;
        });
    }
    readLoop(backend, ws) {
        return __awaiter(this, void 0, void 0, function* () {
            return AdbTransportProtocolHandler_1.default.startPullPushLoop(() => {
                return backend.connected && (ws.readyState === ws.CONNECTING || ws.readyState === ws.OPEN);
            }, (length) => __awaiter(this, void 0, void 0, function* () {
                return backend.read(length);
            }), (buffer) => __awaiter(this, void 0, void 0, function* () {
                return this.wsSendOrIgnore(ws, buffer, backend.serial);
            }), {
                tag: backend.serial,
                direction: "==>",
            });
        });
    }
    writeLoopCallback(backend) {
        const dataEventHandler = AdbTransportProtocolHandler_1.default.createDataEventHandler((buffer) => __awaiter(this, void 0, void 0, function* () {
            return this.backendWriteOrIgnore(backend, buffer, backend.serial);
        }), {
            tag: backend.serial,
            direction: "<==",
        });
        return (event) => {
            dataEventHandler(event.data);
        };
    }
    pipe(ws) {
        return __awaiter(this, void 0, void 0, function* () {
            ws.onmessage = this.writeLoopCallback(this);
            this.readLoop(this, ws).then(() => {
                this.handleDisconnect();
            });
        });
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            this._connected = false;
            this._usb.removeEventListener('disconnect', this.handleDisconnect);
            this.events.removeAllListeners();
            try {
                // Close currently can throw error in node. Ignore.
                yield this._device.close();
            }
            catch (e) {
                // logger.log(e.message);
            }
        });
    }
}
exports.AdbWebUsbTransport = AdbWebUsbTransport;
//# sourceMappingURL=AdbWebUsbTransport.js.map