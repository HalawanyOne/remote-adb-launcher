{"version":3,"file":"main.7c651efa5921f40251eb.bundle.js","mappings":"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","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///./src/client/AdbTransportProtocolHandler.ts","webpack:///./src/client/AdbWebUsbTransport.ts","webpack:///./src/client/RemoteAdbDevice.ts","webpack:///./src/client/ServerConnection.ts","webpack:///./src/client/UsbDeviceManager.ts","webpack:///./src/common/handshake.ts","webpack:///./src/common/logger.ts","webpack:///./src/web/components/app.tsx","webpack:///./src/web/components/device.tsx","webpack:///./src/web/components/status.tsx","webpack:///./src/web/index.tsx","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// This class knows and handles ADB Transport protocol.\n// Details: https://android.googlesource.com/platform/packages/modules/adb/+/master/protocol.txt\n\nimport logger from '../common/logger';\n\nexport type LoggerConfig = {\n    // enabled: boolean,\n    tag: string,\n    direction: \"<==\"|\"==>\"\n}\n\nexport class AdbTransportProtocolHandler {\n    private static getPayloadLength(headerBuffer: ArrayBuffer) {\n        // Get the fourth 32 bit integer from the header. This is the payload length\n        let header = new DataView(headerBuffer);\n        return header.getUint32(12 /* byteOffset */, true /* littleEndian */);\n    }\n\n    private static concatBuffers(b1: ArrayBuffer, b2: ArrayBuffer): ArrayBuffer {\n        let tmp = new Uint8Array(b1.byteLength + b2.byteLength);\n\n        tmp.set(new Uint8Array(b1), 0);\n        tmp.set(new Uint8Array(b2), b1.byteLength);\n\n        return tmp.buffer;\n    }\n\n    // Starts the read-write loop for piping adb transport.\n    // Useful when input data can be read on demand.\n    public static async startPullPushLoop(isConnected: () => boolean, pull: (length: number) => Promise<ArrayBuffer>, push: (buffer: ArrayBuffer) => Promise<void>, loggerConfig: LoggerConfig) {\n        try {\n            do {\n                // Read header\n                let buffer: ArrayBuffer = await pull(24);\n\n                // If we don't get required data, chances are connection is gone\n                // Ignore and try again\n                while (buffer.byteLength !== 24) {\n                    continue;\n                }\n\n                await push(buffer);   // Push header\n\n                let payload_length = this.getPayloadLength(buffer);\n\n                logger.log(loggerConfig.tag, loggerConfig.direction, \"header\", payload_length);\n\n                // Read payload as well\n                while (payload_length > 0) {\n                    buffer = await pull(payload_length);\n                    await push(buffer);\n\n                    logger.log(loggerConfig.tag, loggerConfig.direction, `payload ${payload_length} bytes`);\n                    payload_length -= buffer.byteLength;\n                }\n            }\n            while (isConnected());\n        }\n        catch (e) {\n            logger.error(loggerConfig.tag, e);\n        }\n\n        return;\n    }\n\n    // Returns a function which takes data and calls push for each header and payload as and when available for piping the adb transport.\n    // This is useful and input data is available in form of \"data\" or \"message\" callbacks, instead of on demand.\n    public static createDataEventHandler(push: (buffer: ArrayBuffer) => Promise<void>, loggerConfig: LoggerConfig): (data: ArrayBuffer) => void {\n        const AWAITING_HEADER = \"AWAITING_HEADER\";\n        const AWAITING_PAYLOAD = \"AWAITING_PAYLOAD\";\n\n        let state = AWAITING_HEADER;\n        let pending_data = new ArrayBuffer(0);\n        let payload_length = 0;\n\n        let lastPromise = Promise.resolve();\n\n        let handleWriteData = async (data: ArrayBuffer) => {\n            if (pending_data.byteLength > 0) {\n                data = this.concatBuffers(pending_data, data);\n                pending_data = new ArrayBuffer(0);\n            }\n\n            switch (state) {\n                case AWAITING_HEADER:\n                    if (data.byteLength < 24) {\n                        pending_data = data;\n                        logger.log(`Was expecting 24 bytes, but got ${data.byteLength} bytes. Waiting for more data`);\n                    }\n                    else {\n                        let buffer = data.slice(0, 24);\n                        await push(buffer);\n\n                        // let packetHeader = await parsePacketHeader(buffer, backend);\n                        payload_length = this.getPayloadLength(buffer); //packetHeader.payloadLength;\n\n                        logger.log(loggerConfig.tag, loggerConfig.direction, \"header\", payload_length);\n\n                        if (payload_length > 0) {\n                            state = AWAITING_PAYLOAD;\n                        }\n\n                        if (data.byteLength > 24) {\n                            await handleWriteData(data.slice(24));\n                        }\n                    }\n\n                    break;\n                case AWAITING_PAYLOAD:\n                    if (data.byteLength > payload_length) {\n                        let boundry = payload_length;\n                        await handleWriteData(data.slice(0, boundry));\n                        await handleWriteData(data.slice(boundry));\n                    }\n                    else {\n                        await push(data);\n                        logger.log(loggerConfig.tag, loggerConfig.direction, `payload ${payload_length} bytes`);\n\n                        payload_length -= data.byteLength;\n\n                        if (payload_length == 0) {\n                            state = AWAITING_HEADER;\n\n                            // Sometimes we stop recieving read data after a large transfer.\n                            // Writing something seems to resume the communication.\n                            // Writing a zero length buffer here as a workaround, not sure if this is expected.\n                            await push(new Uint8Array().buffer);\n                        }\n                    }\n\n                    break;\n            }\n        }\n\n        return (data: ArrayBuffer) => {\n            lastPromise = lastPromise.then(async () => { await handleWriteData(data); });\n        }\n    }\n}\n\nexport default AdbTransportProtocolHandler;","import { EventEmitter } from 'events';\nimport logger from '../common/logger';\nimport { AdbTransport, WebSocket } from './AdbTransport';\nimport AdbTransportProtocolHandler from './AdbTransportProtocolHandler';\n\nexport const WebUsbDeviceFilter: USBDeviceFilter = {\n    classCode: 0xFF,\n    subclassCode: 0x42,\n    protocolCode: 1,\n};\n\n// Adopted from https://github.com/yume-chan/ya-webadb/blob/v0.0.9/packages/adb-backend-webusb/src/backend.ts\nexport class AdbWebUsbTransport implements AdbTransport {\n    private _usb: USB;\n    private _device: USBDevice;\n\n    readonly type = \"USB\";\n\n    public get serial(): string { return this._device.serialNumber!; }\n\n    public get name(): string { return this._device.productName!; }\n\n    private _connected = false;\n    public get connected() { return this._connected; }\n\n    private _bytesTransferred = {\n        up: 0,\n        down: 0,\n    }\n    get bytesTransferred() { return this._bytesTransferred; }\n\n    private readonly events = new EventEmitter();\n    public readonly ondisconnect = (listener: (e: Event) => void) => this.events.addListener('disconnect', listener);\n\n    private _inEndpointNumber!: number;\n    private _outEndpointNumber!: number;\n\n    public constructor(usb: USB, device: USBDevice) {\n        this._usb = usb\n        this._device = device;\n\n        this._usb.addEventListener('disconnect', this.handleDisconnect);\n    }\n\n    private handleDisconnect = (e?: USBConnectionEvent) => {\n        if (typeof e === \"undefined\" || e.device === this._device) {\n            this._connected = false;\n            this.events.emit('disconnect');\n        }\n    };\n\n    public async connect(): Promise<void> {\n        if (!this._device.opened) {\n            await this._device.open();\n        }\n\n        for (const configuration of this._device.configurations) {\n            for (const interface_ of configuration.interfaces) {\n                for (const alternate of interface_.alternates) {\n                    if (alternate.interfaceSubclass === WebUsbDeviceFilter.subclassCode &&\n                        alternate.interfaceClass === WebUsbDeviceFilter.classCode &&\n                        alternate.interfaceProtocol === WebUsbDeviceFilter.protocolCode) {\n                        if (this._device.configuration?.configurationValue !== configuration.configurationValue) {\n                            await this._device.selectConfiguration(configuration.configurationValue);\n                        }\n\n                        if (!interface_.claimed) {\n                            await this._device.claimInterface(interface_.interfaceNumber);\n                        }\n\n                        if (interface_.alternate.alternateSetting !== alternate.alternateSetting) {\n                            await this._device.selectAlternateInterface(interface_.interfaceNumber, alternate.alternateSetting);\n                        }\n\n                        for (const endpoint of alternate.endpoints) {\n                            switch (endpoint.direction) {\n                                case 'in':\n                                    this._inEndpointNumber = endpoint.endpointNumber;\n                                    if (this._outEndpointNumber !== undefined) {\n                                        this._connected = true;\n                                        return;\n                                    }\n                                    break;\n                                case 'out':\n                                    this._outEndpointNumber = endpoint.endpointNumber;\n                                    if (this._inEndpointNumber !== undefined) {\n                                        this._connected = true;\n                                        return;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        throw new Error('Unknown error while connecting to WebUsb device.');\n    }\n\n    private async write(buffer: ArrayBuffer): Promise<void> {\n        await this._device.transferOut(this._outEndpointNumber, buffer);\n    }\n\n    private async read(length: number): Promise<ArrayBuffer> {\n        const result = await this._device.transferIn(this._inEndpointNumber, length);\n\n        if (result.status === 'stall') {\n            await this._device.clearHalt('in', this._inEndpointNumber);\n        }\n\n        const { buffer } = result.data!;\n        return buffer;\n    }\n\n    private wsSendOrIgnore(ws: WebSocket, buffer: ArrayBuffer, logTag: string) {\n        // We sometimes need to ignore stale data coming from usb before the connection is initialized from the adb server.\n        if (ws.readyState !== ws.OPEN) {\n            logger.warn(logTag, \"WebSocket is not open. Ignoring sent data\");\n            return;\n        }\n        ws.send(buffer);\n\n        this._bytesTransferred.up += buffer.byteLength;\n    }\n\n    private async backendWriteOrIgnore(backend: this, buffer: ArrayBuffer, logTag: string) {\n        // We sometimes need to ignore stale data coming from usb before the connection is initialized from the adb server.\n        if (!backend.connected) {\n            logger.warn(logTag, \"Device is not connected. Ignoring sent data\");\n            return;\n        }\n        await backend.write(buffer);\n\n        this._bytesTransferred.down += buffer.byteLength;\n    }\n\n    private async readLoop(backend: this, ws: WebSocket) {\n        return AdbTransportProtocolHandler.startPullPushLoop(\n            () => { // isConnected\n                return backend.connected && (ws.readyState === ws.CONNECTING || ws.readyState === ws.OPEN);\n            },\n            async (length: number) => { // pull\n                return backend.read(length);\n            },\n            async (buffer: ArrayBuffer) => { // push\n                return this.wsSendOrIgnore(ws, buffer, backend.serial);\n            },\n            {   // loggerConfig\n                tag: backend.serial,\n                direction: \"==>\",\n            }\n        )\n    }\n\n    private writeLoopCallback(backend: this): ((e: any) => void) {\n        const dataEventHandler = AdbTransportProtocolHandler.createDataEventHandler(\n            async (buffer: ArrayBuffer) => {   // push\n                return this.backendWriteOrIgnore(backend, buffer, backend.serial)\n            },\n            {   // loggerConfig\n                tag: backend.serial,\n                direction: \"<==\",\n            }\n        );\n\n        return (event: MessageEvent) => {\n            dataEventHandler(event.data);\n        }\n    }\n\n    public async pipe(ws: WebSocket) {\n        ws.onmessage = this.writeLoopCallback(this);\n\n        this.readLoop(this, ws).then(() => {\n            this.handleDisconnect();\n        });\n    }\n\n    public async dispose() {\n        this._connected = false;\n        this._usb.removeEventListener('disconnect', this.handleDisconnect);\n        this.events.removeAllListeners();\n        try {\n            // Close currently can throw error in node. Ignore.\n            await this._device.close();\n        }\n        catch (e: any) {\n            // logger.log(e.message);\n        }\n    }\n}\n","import { EventEmitter } from \"events\";\nimport logger from '../common/logger';\nimport { AdbTransport } from \"./AdbTransport\";\nimport { ServerConnection, WebSocket } from \"./ServerConnection\";\nimport { ClientHandshake, getRemoteHandshake, ServerHandshake } from \"../common/handshake\";\n\n\nexport class RemoteAdbDevice extends EventEmitter {\n    private backend: AdbTransport;\n    private ws: WebSocket;\n    private serverHandshake: ServerHandshake;\n\n    private _connecting: boolean = false;\n\n    get serial(): string {\n        return this.backend.serial;\n    }\n\n    get name(): string {\n        return this.backend.name;\n    }\n\n    get remoteSerial(): string|undefined {\n        return this.serverHandshake?.serial;\n    }\n\n    get bytesTransferred() {\n        return this.backend.bytesTransferred;\n    }\n\n    constructor(backend: AdbTransport) {\n        super()\n\n        this.backend = backend;\n    }\n\n    get connected(): boolean {\n        return this.backend.connected && this.ws?.readyState == WebSocket.OPEN && !this._connecting;\n    }\n\n    get connecting(): boolean {\n        return this._connecting;\n    }\n\n    connect = async (serverConnection: ServerConnection) => {\n        this._connecting = true;\n\n        try {\n            // Connect with the backend\n            await this.backend.connect();\n            logger.log(this.backend.serial, `${this.backend.type} connected`);\n            this.backend.ondisconnect(() => {\n                logger.log(this.backend.serial, `${this.backend.type} closed. Closing WebSocket.`);\n                this.disconnectWebSocket(true);\n            });\n\n            // Connect to WebSocket\n            this.ws = await new Promise<WebSocket>(async (resolve, reject) => {\n                const ws = await serverConnection.createWebSocket(\"\");\n\n                ws.binaryType = \"arraybuffer\";\n\n                let resolved = false;\n                ws.onopen = () => {\n                    resolved = true;\n                    resolve(ws)\n                }\n                ws.onerror = () => {}   // This is required in node to not crash on error\n                ws.onclose = () => {\n                    if (!resolved) { reject(new Error(\"Error connecting to WebSocket\")); }\n                }\n            }).catch(async (e) => {\n                await this.disconnectBackend(false);\n\n                throw e;\n            });\n\n            this.ws.onerror = (e) => {\n                logger.log(this.backend.serial, `WebSocket error: ${e}`);\n            }\n\n            this.ws.onclose = (e) => {\n                logger.log(this.backend.serial, `WebSocket closed (code: ${e.code}${e.reason ? `, reason: ${e.reason}` : \"\"}). Closing device.`);\n                this.disconnectBackend(true);\n            }\n\n            logger.log(this.backend.serial, \"WebSocket connected. Waiting for handshake...\");\n\n            // Send handshake data\n            const handshakeData: ClientHandshake = {\n                type: \"handshake\",\n                name: this.name,\n                serial: this.serial\n            }\n\n            this.ws.send(JSON.stringify(handshakeData));\n\n            // Wait for the handshake response\n            this.serverHandshake = await getRemoteHandshake<ServerHandshake>(this.ws);\n\n            logger.log(this.backend.serial, `Connected as ${this.remoteSerial}`);\n\n            await this.backend.pipe(this.ws);\n\n            this.emit(\"connected\", this);\n        } catch(e) {\n            logger.log(this.backend.serial, `Error connecting: ${e.message}`);\n            await this.disconnectBackend(false);\n            await this.disconnectWebSocket(false);\n\n            throw e;\n        } finally {\n            this._connecting = false;\n        }\n    }\n\n    private disconnectBackend = async (emit: boolean) => {\n        await this.backend.dispose();\n        logger.log(this.backend.serial, `${this.backend.type} closed`);\n\n        if (emit) {\n            this.emit(\"disconnected\", this);\n        }\n    }\n\n    private disconnectWebSocket = async (emit: boolean) => {\n        if (!this.ws) {\n            return;\n        }\n\n        this.ws.onclose = undefined;\n        this.ws.close();\n        logger.log(this.backend.serial, `WebSocket closed`);\n\n        if (emit) {\n            this.emit(\"disconnected\", this);\n        }\n    }\n\n    disconnect = async () => {\n        await this.disconnectBackend(false);\n        await this.disconnectWebSocket(false);\n\n        this.emit(\"disconnected\", this);\n    }\n}\n","import EventEmitter from \"events\";\nimport WebSocket from 'isomorphic-ws';\n\n// Imports only available when running in node\nimport nodeFetch from \"node-fetch\";\nimport makeFetchCookie from 'fetch-cookie'\nimport type { CookieJar } from \"tough-cookie\";\n\nexport { WebSocket };\n\nconst url = {\n    status: \"status\",\n    login: \"login\",\n}\n\nexport type ServerStatus = {\n    _error?: string,\n    loginSupported?: boolean,\n    loginRequired?: boolean,\n}\n\nexport class ServerConnection {\n    private serverAddress: string;\n\n    private events = new EventEmitter();\n\n    private updateLoopRunning = false;\n    private lastServerStatusPromise = Promise.resolve({});\n\n    private cookieJar: CookieJar = undefined;\n    private _fetch: any;    // There are some differences in node-fetch and fetch.\n\n    constructor(address: string) {\n        this.serverAddress = address;\n\n        if (typeof window !== \"undefined\" && typeof fetch === \"function\") {\n            this._fetch = fetch.bind(window);\n        }\n        else {\n            this.cookieJar = new makeFetchCookie.toughCookie.CookieJar();\n            this._fetch = makeFetchCookie(nodeFetch, this.cookieJar);\n        }\n    }\n\n    private resolveUrl(url: string, protocol: \"http\"|\"ws\") {\n        let resolvedUrl = new URL(url, this.serverAddress);\n\n        resolvedUrl.protocol = resolvedUrl.protocol.replace(\"http\", protocol);\n\n        return resolvedUrl.href;\n    }\n\n    fetch(url: string, init?: RequestInit): Promise<Response> {\n        let resolvedUrl = this.resolveUrl(url, \"http\");\n\n        return this._fetch(resolvedUrl, init);\n    }\n\n    async createWebSocket(url: string) {\n        const resolvedUrl = this.resolveUrl(url ?? \"\", \"ws\");\n        if (this.cookieJar) {\n            return new WebSocket(resolvedUrl, {\n                headers: {\n                    \"Cookie\": await this.cookieJar.getCookieString(resolvedUrl)\n                }\n            });\n        }\n        else {\n            return new WebSocket(resolvedUrl);\n        }\n    }\n\n    login = async (password: string) => {\n        const res = await this.fetch(url.login, {\n            method: \"post\",\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({password: password})\n        });\n\n        if (res.status !== 200) {\n            throw new Error(`Status code ${res.status}`);\n        }\n\n        const data: any = await res.json();\n        if (data.result !== \"OK\") {\n            throw new Error(data.message ?? \"Unknown error\");\n        }\n    }\n\n    monitorServerStatus = async (callback: (status: ServerStatus) => void) => {\n        this.events.on(\"statusChanged\", callback);\n\n        if (!this.updateLoopRunning) {\n            this.updateStatusLoop();\n        }\n    }\n\n    getServerStatus = async (): Promise<ServerStatus> => {\n        await this.lastServerStatusPromise\n        this.lastServerStatusPromise = this.fetchServerStatus();\n\n        const status = await this.lastServerStatusPromise;\n\n        this.events.emit(\"statusChanged\", status);\n        return status;\n    }\n\n    private updateStatusLoop = async () => {\n        this.updateLoopRunning = true;\n\n        await this.getServerStatus();\n        setTimeout(this.updateStatusLoop, 5000);\n    }\n\n    private fetchServerStatus = async (): Promise<ServerStatus> => {\n        try {\n            const res = await this.fetch(url.status, {\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n            });\n\n            if (res.status !== 200) {\n                throw new Error(`Status code ${res.status}`);\n            }\n\n            return await res.json();\n        }\n        catch (e) {\n            return {\n                _error: e.message\n            }\n        }\n    }\n}\n\n","import EventEmitter = require('events');\n\nimport { WebUSB } from 'usb';\n\nimport logger from '../common/logger';\nimport { AdbWebUsbTransport, WebUsbDeviceFilter } from './AdbWebUsbTransport';\nimport { RemoteAdbDevice } from './RemoteAdbDevice';\n\n\nclass UsbDeviceManagerSingleton {\n    private events = new EventEmitter();\n    private connectedDevices = new Map<USBDevice, RemoteAdbDevice>();\n\n    private _usb: USB = undefined;\n    private _usbInitialized: boolean = false;\n    private get usb(): USB {\n        if (!this._usbInitialized) {\n            if (typeof navigator !== \"undefined\") {\n                this._usb = navigator?.usb;\n            }\n            if (typeof WebUSB !== \"undefined\") {\n                this._usb = new WebUSB({\n                    allowAllDevices: true\n                });\n            }\n\n            this._usbInitialized = true;\n        }\n\n        return this._usb;\n    }\n\n    constructor() {\n        this.events.once(\"newListener\", (event, listener) => {\n            this.usb.addEventListener('connect', this.refreshDevices);\n            this.usb.addEventListener('disconnect', this.refreshDevices);\n        })\n    }\n\n    isSupported = () => {\n        return !!this.usb\n    }\n\n    requestDevice = async () => {\n        let device = await this.usb.requestDevice({ filters: [WebUsbDeviceFilter] });\n\n        this.refreshDevices();\n\n        return device\n    }\n\n    private createRemoteAdbDevice = (d: USBDevice) => {\n        let device = new RemoteAdbDevice(new AdbWebUsbTransport(this.usb, d));\n        device.on(\"connected\", this.refreshDevices);\n        device.on(\"disconnected\", this.refreshDevices);\n\n        return device;\n    }\n\n    private refreshDevices = async () => {\n        if (!this.events.listenerCount(\"devices\")) {\n            // If not listener is registered, don't do anything.\n            return;\n        }\n\n        logger.log(\"Refreshing device list\");\n\n        const devices = await this.getDevices();\n\n        this.events.emit(\"devices\", devices);\n\n        return devices\n    }\n\n    getDevices = async () => {\n        const currentDevices = new Map<USBDevice, RemoteAdbDevice>();\n\n        const devices = (await this.usb.getDevices())\n            .filter(d => {\n                return d.configuration?.interfaces.some(iface => {\n                    return iface.alternate.interfaceClass === WebUsbDeviceFilter.classCode\n                        && iface.alternate.interfaceSubclass === WebUsbDeviceFilter.subclassCode\n                        && iface.alternate.interfaceProtocol === WebUsbDeviceFilter.protocolCode\n                });\n            })\n            .map((d) => {\n                let device = this.connectedDevices.get(d) ?? this.createRemoteAdbDevice(d);\n\n                currentDevices.set(d, device);\n\n                return device;\n            });\n\n        this.connectedDevices = currentDevices;\n\n        return devices;\n    }\n\n    monitorDevices = (callback: (devices: RemoteAdbDevice[]) => void) => {\n        this.events.on('devices', callback);\n\n        this.refreshDevices();\n    }\n}\n\nexport const UsbDeviceManager = new UsbDeviceManagerSingleton();","import type WebSocket from 'isomorphic-ws';\n\nexport type ClientHandshake = {\n    type: \"handshake\",\n    name: string,\n    serial: string,\n}\n\nexport type ServerHandshake = {\n    type: \"handshake\",\n    serial: string,\n}\n\nexport function getRemoteHandshake<T extends ClientHandshake|ServerHandshake>(ws: WebSocket): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n        const onWebsocketClose = () => {\n            reject(new Error(\"WebSocket closed while waiting for handshake\"));\n        };\n\n        ws.addEventListener(\"close\", onWebsocketClose, {once: true});\n\n        ws.addEventListener(\"message\", (message) => {\n            try {\n                const handshakeData: T = JSON.parse(message.data);\n\n                if (handshakeData.type !== \"handshake\") {\n                    throw new Error(\"Unexpected handshake message\");\n                }\n\n                resolve(handshakeData);\n            } catch(e) {\n                reject(new Error(`Handshake failed: ${e.message}`));\n            } finally {\n                ws.removeEventListener(\"close\", onWebsocketClose);\n            }\n        }, {once: true});\n    });\n}\n","export type Logger = {\n    log(...data: any[]): void;\n\n    debug(...data: any[]): void;\n    info(...data: any[]): void;\n    warn(...data: any[]): void;\n    error(...data: any[]): void;\n}\n\nclass GlobalLogger implements Logger {\n    private _logger: Logger = console;\n\n    setGlobalLogger(logger: Logger) {\n        this._logger = logger;\n    }\n\n    log(...data: any[]): void {\n        this._logger.log(...data);\n    }\n\n    debug(...data: any[]): void {\n        this._logger.debug(...data);\n    }\n\n    info(...data: any[]): void {\n        this._logger.info(...data);\n    }\n\n    warn(...data: any[]): void {\n        this._logger.warn(...data);\n    }\n\n    error(...data: any[]): void {\n        this._logger.error(...data);\n    }\n}\n\nlet _logger = new GlobalLogger();\n\nexport let logger: Logger = _logger;\nexport let setLogger: (logger: Logger) => void = _logger.setGlobalLogger.bind(_logger);\n\nexport default logger;\n","import { useState, useEffect, useCallback } from 'react';\nimport { Separator } from '@fluentui/react/lib/Separator';\nimport { Stack } from '@fluentui/react/lib/Stack';\nimport { Text } from '@fluentui/react/lib/Text';\nimport { Link } from '@fluentui/react/lib/Link';\nimport { Toggle } from '@fluentui/react/lib/Toggle';\nimport { PrimaryButton } from '@fluentui/react/lib/Button';\nimport { NeutralColors } from '@fluentui/theme';\nimport { Device } from './device';\n\nimport { RemoteAdbDevice } from '../../client/RemoteAdbDevice';\nimport { UsbDeviceManager } from '../../client/UsbDeviceManager';\nimport { ServerConnection } from '../../client/ServerConnection';\n\nimport { initializeIcons } from '@fluentui/font-icons-mdl2';\nimport { Status } from './status';\ninitializeIcons();\n\nconst enum StoredItemKeys {\n    SettingsAutoConnectDevices = \"SettingsAutoConnectDevices\"\n}\n\nconst serverConnection = new ServerConnection(window.location.href);\n\nexport function App() {\n    let [devices, setDevices] = useState<RemoteAdbDevice[]>([]);\n    let [serverConnectionReady, setServerConnectionReady] = useState(false);\n    let [autoConnect, setAutoConnect] = useState(() => localStorage?.getItem(StoredItemKeys.SettingsAutoConnectDevices) === \"true\");\n\n    useEffect(() => {\n        if (!UsbDeviceManager.isSupported()) {\n            return;\n        }\n\n        UsbDeviceManager.monitorDevices(setDevices);\n    }, []);\n\n    const onAutoConnectToggle = useCallback((ev, checked) => {\n        setAutoConnect(checked);\n        localStorage?.setItem(StoredItemKeys.SettingsAutoConnectDevices, checked.toString());\n    }, [setAutoConnect]);\n\n    return UsbDeviceManager.isSupported() ? (\n        <div style={{maxWidth: 650, margin: \"0 auto\"}}>\n            {/* <Text variant=\"large\">Welcome</Text> */}\n            <Stack tokens={{padding: 'l2', childrenGap: 'l2'}}>\n                <Stack.Item align=\"center\">\n                    <Text variant=\"mediumPlus\" style={{color: NeutralColors.gray130}}>Share connected Android devices for debugging on the server</Text>\n                </Stack.Item>\n                <Status serverConnection={serverConnection} setServerConnectionReady={setServerConnectionReady} />\n                <Separator>Connected Devices</Separator>\n                <Stack horizontal tokens={{childrenGap: 'm', padding: 's'}} horizontalAlign=\"center\" verticalAlign=\"center\">\n                    <Text>Device not visible in the list below?</Text>\n                    <PrimaryButton text=\"Add device\" id=\"request\" onClick={UsbDeviceManager.requestDevice} iconProps={{iconName: \"Add\"}} />\n                </Stack>\n                <Stack.Item align=\"center\">\n                    <Toggle label=\"Auto-connect devices to remote when available\" inlineLabel onChange={onAutoConnectToggle} checked={autoConnect} />\n                </Stack.Item>\n                {!devices.length && (\n                    <Stack.Item align=\"center\">\n                        <Text style={{color: NeutralColors.gray90}}>No devices found</Text>\n                    </Stack.Item>\n                )}\n                <Stack tokens={{childrenGap: 'l2', padding: 's'}}>\n                    {devices.map((device) => (<Device device={device} key={device.serial} serverConnection={serverConnection} autoConnect={autoConnect} serverConnectionReady={serverConnectionReady} />))}\n                </Stack>\n            </Stack>\n        </div>\n    ) : (\n        <div style={{maxWidth: 650, margin: \"0 auto\"}}>\n            <Stack tokens={{padding: 'l2', childrenGap: 'l2'}}>\n                <Stack.Item align=\"center\">\n                    <Text variant=\"large\">Unsupported browser or configuration</Text>\n                </Stack.Item>\n                <Stack.Item align=\"center\">\n                    <Text>\n                        Please make sure:\n                        <ul>\n                            <li>That you are using one of <Link href=\"https://caniuse.com/webusb\">the browsers that support WebUSB API</Link>.\n                                Microsoft Edge and Google Chrome are supported.</li>\n                            { !window.isSecureContext && <li>That this page is opened securely with \"https\".\n                                A <Link href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\">secure context</Link> is required for the <Link href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebUSB_API\">WebUSB API</Link> to work. </li> } \n                        </ul>\n                    </Text>\n                </Stack.Item>\n            </Stack>\n        </div>\n    );\n}","import { useState, useEffect, useCallback } from 'react';\nimport { Stack } from '@fluentui/react/lib/Stack';\nimport { Text } from '@fluentui/react/lib/Text';\nimport { Label } from '@fluentui/react/lib/Label';\nimport { Icon } from '@fluentui/react/lib/Icon';\nimport { MessageBar, MessageBarType } from '@fluentui/react/lib/MessageBar';\nimport { DefaultButton, PrimaryButton } from '@fluentui/react/lib/Button';\nimport { NeutralColors } from '@fluentui/theme';\n\nimport logger from '../../common/logger';\nimport { RemoteAdbDevice } from '../../client/RemoteAdbDevice';\nimport { ServerConnection } from '../../client/ServerConnection';\n\nimport * as bytes from 'bytes';\n\nfunction CommunicationSpeed(props: {device: RemoteAdbDevice}) {\n    let device: RemoteAdbDevice = props.device;\n    let [speedCounterState, setSpeedConunterState] = useState({up: 0, down: 0, time: 0});\n    let [speed, setSpeed] = useState({up: 0, down: 0});\n\n    let updateSpeed = useCallback(() => {\n        let currentTime = new Date().getTime();\n        let timeElapsed = currentTime - speedCounterState.time; // Milliseconds\n\n        setSpeed({\n            up: Math.floor((device.bytesTransferred.up - speedCounterState.up) * 1000 / timeElapsed),\n            down: Math.floor((device.bytesTransferred.down - speedCounterState.down) * 1000 / timeElapsed),\n        });\n\n        // logger.log(currentTime, timeElapsed, device.bytesTransferred, speedCounterState);\n\n        setSpeedConunterState({\n            up: device.bytesTransferred.up,\n            down: device.bytesTransferred.down,\n            time: currentTime\n        });\n    }, [setSpeed, setSpeedConunterState, speedCounterState]);\n\n    // Update speed periodically when connected.\n    useEffect(() => {\n        let interval: NodeJS.Timer = null;\n        if (device.connected) {\n            if (speedCounterState.time === 0) updateSpeed();\n            interval = setInterval(updateSpeed, 1000);\n        } \n        else {\n            clearInterval(interval);\n        }\n        return () => clearInterval(interval);\n    }, [device.connected, speedCounterState]);\n\n    // Cleanup speed and speedCounterState on disconnect\n    useEffect(() => {\n        if (!device.connected) {\n            setSpeedConunterState({\n                up: 0, down: 0, time: 0\n            });\n            setSpeed({\n                up: 0, down: 0\n            })\n        }\n    }, [device.connected]);\n\n    let formatSpeed = useCallback((b) => {\n        return `${bytes.format(b, {decimalPlaces: 1, unitSeparator: ' '})}/s`;\n    }, []);\n\n    return device.connected && (\n        <Stack horizontal verticalAlign=\"center\" tokens={{childrenGap: 's1'}}>\n            <Text>Up: {formatSpeed(speed.up)}</Text>\n            <Text>&nbsp;</Text>\n            <Text>Down: {formatSpeed(speed.down)}</Text>\n        </Stack>\n    )\n}\n\nexport function Device(props: {device: RemoteAdbDevice, serverConnection: ServerConnection, autoConnect: boolean, serverConnectionReady: boolean}) {\n    const [error, setError] = useState(undefined);\n    const [isConnecting, setConnecting] = useState(false);\n\n    const { device, serverConnection, autoConnect, serverConnectionReady } = props;\n\n    useEffect(() => {\n        if (!serverConnectionReady) {\n            return;\n        }\n\n        if (autoConnect && !device.connected && !device.connecting && !isConnecting) {\n            onConnect();\n        }\n    }, [autoConnect, serverConnectionReady]);\n\n    const onConnect = useCallback(async () => {\n        let connecting = true;\n        setTimeout(() => setConnecting(connecting), 100); // delay to reduce flicker\n\n        try {\n            resetError();\n\n            let wsUrl = new URL(window.location.href);\n            wsUrl.protocol = wsUrl.protocol.replace('http', 'ws');\n\n            await device.connect(serverConnection);\n        }\n        catch (e) {\n            logger.log(e);\n            setError(e.message);\n        }\n        connecting = false;\n        setConnecting(false);\n    }, [device, setError, setConnecting]);\n\n    const resetError = useCallback(() => {\n        setError(undefined);\n    }, [setError]);\n\n    return (\n        <div style={{border: '1px solid', borderColor: NeutralColors.gray70}}>\n            <Stack tokens={{padding: 'm', childrenGap: 'm'}}>\n                <Stack horizontal tokens={{childrenGap: 'l1'}} verticalAlign=\"center\" >\n                    <Icon iconName=\"CellPhone\" style={{fontSize: \"larger\", fontWeight: \"bold\"}} />\n                    <Stack.Item grow>\n                        <Label>{device.name} ({device.serial})</Label>\n                    </Stack.Item>\n                    {\n                    device.connected ? \n                        <DefaultButton text=\"Disconnect\" onClick={device.disconnect} /> :\n                    isConnecting ?\n                        <DefaultButton text=\"Connecting...\" disabled /> :\n                    // Otherwise\n                        <PrimaryButton text=\"Connect to remote\" onClick={onConnect} />\n                    }\n                </Stack>\n                <Stack horizontal tokens={{childrenGap: 'l1'}} verticalAlign=\"center\" >\n                    <Stack.Item grow={!device.connected}>\n                        { \n                            error ?\n                                (<MessageBar\n                                    messageBarType={MessageBarType.error}\n                                    isMultiline={false}\n                                    onDismiss={resetError}\n                                    dismissButtonAriaLabel=\"Dismiss\"\n                                >\n                                    \"{error}\"\n                                </MessageBar>) :\n                            device.connected ?\n                                (<MessageBar\n                                    messageBarType={MessageBarType.success}\n                                    isMultiline={false}\n                                >\n                                    Connected as <code style={{userSelect: 'all'}}>{device.remoteSerial}</code>\n                                </MessageBar>) :\n                            isConnecting ?\n                                (<MessageBar isMultiline={false}>\n                                    Connecting to remote...\n                                </MessageBar>) :\n                            // Otherwise\n                                (<MessageBar isMultiline={false}>\n                                    Ready to connect\n                                </MessageBar>)\n                        }\n                    </Stack.Item>\n                    {device.connected && <Stack.Item grow>&nbsp;</Stack.Item>}\n                    <CommunicationSpeed device={device} />\n                </Stack>\n            </Stack>\n        </div>\n    )\n}\n","import { useState, useEffect, useCallback, Dispatch, SetStateAction, useMemo } from 'react';\nimport { Stack } from '@fluentui/react/lib/Stack';\nimport { Dialog, DialogType, DialogFooter } from '@fluentui/react/lib/Dialog';\nimport { TextField } from '@fluentui/react/lib/TextField';\nimport { ProgressIndicator } from '@fluentui/react/lib/ProgressIndicator';\nimport { MessageBar, MessageBarType } from '@fluentui/react/lib/MessageBar';\nimport { DefaultButton, MessageBarButton, PrimaryButton } from '@fluentui/react/lib/Button';\nimport { Separator } from '@fluentui/react/lib/Separator';\n\nimport { ServerStatus, ServerConnection } from '../../client/ServerConnection';\n\nfunction DelayedProgressIndicator() {\n    const [showProgress, setShowProgress] = useState(false);\n\n    useEffect(() => {\n        let timeout = setTimeout(() => {\n            setShowProgress(true);\n        }, 200);\n\n        return () => clearTimeout(timeout);\n    }, []);\n\n    return showProgress ? <ProgressIndicator /> : null;\n}\n\n\nfunction LoginDialog(props: {showDialog: boolean, setShowDialog: Dispatch<SetStateAction<Boolean>>, onLoginSuccess: () => void, serverConnection: ServerConnection}) {\n    const [loginError, setLoginError] = useState(undefined);\n    const [loginSuccess, setLoginSuccess] = useState(false);\n    const [loginProgress, setLoginProgress] = useState(false);\n    const [password, setPassword] = useState(undefined);\n\n    const {showDialog, setShowDialog, onLoginSuccess, serverConnection} = props;\n\n    const hideDialog = useCallback(() => {\n        setShowDialog(false);\n    }, [setShowDialog]);\n\n    const dialogDismissed = useCallback(() => {\n        setLoginError(undefined);\n        setLoginSuccess(false);\n    }, [setLoginError, setLoginSuccess]);\n\n    const handlePasswordChanged = useCallback((event) => {\n        setPassword(event.target.value);\n    }, [setPassword]);\n\n    const resetLoginError = useCallback(() => {\n        setLoginError(undefined);\n    }, [setLoginError]);\n\n    const loginFailed = useCallback((message) => {\n        setLoginProgress(false);\n        setLoginError(message);\n    }, [setLoginProgress, setLoginError]);\n\n    const login = useCallback(async (event) => {\n        resetLoginError();\n        setLoginProgress(true);\n\n        try {\n            await serverConnection.login(password);\n\n            setLoginProgress(false);\n            setLoginSuccess(true);\n            onLoginSuccess();\n        }\n        catch (e) {\n            loginFailed(`Login failed: ${e.message}`);\n        }\n    }, [password, resetLoginError, setLoginProgress, loginFailed, setLoginSuccess, hideDialog, onLoginSuccess]);\n\n    return (\n        <Dialog\n            hidden={!showDialog}\n            onDismiss={hideDialog}\n            dialogContentProps={{type: DialogType.normal, title: \"Login\"}}\n            modalProps={{isBlocking: true, onDismissed: dialogDismissed}}\n            >\n            {loginError && (\n                <MessageBar\n                    messageBarType={MessageBarType.error}\n                    isMultiline={false}\n                    onDismiss={resetLoginError}\n                    dismissButtonAriaLabel=\"Dismiss\"\n                >\n                    {loginError}\n                </MessageBar>\n            )}\n            {loginProgress && (\n                <DelayedProgressIndicator />\n            )}\n            <form>\n                <TextField\n                    label=\"Password\"\n                    type=\"password\"\n                    autoFocus\n                    onChange={handlePasswordChanged}\n                    />\n                <DialogFooter>\n                    <PrimaryButton type=\"submit\" onClick={login} text=\"Login\" disabled={loginProgress || loginSuccess} />\n                    <DefaultButton onClick={hideDialog} text=\"Cancel\" disabled={loginProgress || loginSuccess} />\n                </DialogFooter>\n            </form>\n        </Dialog>\n    );\n}\n\nfunction StatusItem(props: {type: MessageBarType, message: string, muted?: boolean, [key: string]: any}) {\n    const {type, muted, message, ...rest} = props;\n\n    return (\n        <MessageBar messageBarType={type} isMultiline={false} styles={muted && {root: {background: \"transperant\"}}} {...rest}>\n            {message}\n        </MessageBar>\n    );\n}\n\nexport function Status(props: {serverConnection: ServerConnection, setServerConnectionReady: (ready: boolean) => void}) {\n    const [initialized, setInitialized] = useState(false);\n\n    const [statusError, setStatusError] = useState(undefined);\n    const [loginSupported, setLoginSupported] = useState(false);\n    const [loginRequired, setLoginRequired] = useState(false);\n\n    const [showLoginDialog, setShowLoginDialog] = useState(false);\n\n    const { serverConnection, setServerConnectionReady } = props;\n\n    const updateStatus = useCallback(async (status: ServerStatus) => {\n        if (status._error) {\n            setStatusError(`Cannot get server status: ${status._error}`);\n            setServerConnectionReady(false);\n        }\n        else {\n            setStatusError(undefined)\n            setLoginSupported(status.loginSupported);\n            setLoginRequired(status.loginRequired);\n\n            if (status.loginSupported && status.loginRequired) {\n                setServerConnectionReady(false);\n            } else {\n                setServerConnectionReady(true);\n            }\n        }\n\n        setInitialized(true);\n    }, [setInitialized, setLoginSupported, setLoginRequired, setStatusError, setServerConnectionReady]);\n\n    // Monitor server status\n    useEffect(() => {\n        serverConnection.monitorServerStatus(updateStatus);\n    }, [updateStatus]);\n\n    // Show login dialog once initialized\n    useMemo(() => {\n        if (initialized) {\n            setShowLoginDialog(!statusError && loginSupported && loginRequired);\n        }\n    }, [initialized, statusError, loginSupported, loginRequired]);\n\n    const onLoginSuccess = useCallback(() => {\n        setLoginRequired(false);\n        setServerConnectionReady(true);\n        serverConnection.getServerStatus();\n    }, [setLoginRequired, setServerConnectionReady]);\n\n    return (\n        <>\n            <Separator>Server Status</Separator>\n            <Stack tokens={{padding: \"0 l2\"}}>\n                {initialized ? (\n                    <>\n                        {statusError ? (\n                            <StatusItem type={MessageBarType.error} message={statusError} />\n                        ) : (\n                            <StatusItem type={MessageBarType.success} message=\"Server reachable\" muted />\n                        )}\n                        {!statusError && loginSupported && (loginRequired ? (\n                            <StatusItem type={MessageBarType.warning} message=\"Authentication required\" actions={(\n                                <MessageBarButton text=\"Login\" id=\"request\" onClick={() => setShowLoginDialog(true)} />\n                            )} />\n                        ) : (\n                            <StatusItem type={MessageBarType.success} message=\"Authentication successful\" muted />\n                        ))}\n                    </>\n                ) : (\n                    <ProgressIndicator label=\"Connecting to server...\" />\n                )}\n                <LoginDialog showDialog={showLoginDialog} setShowDialog={setShowLoginDialog} onLoginSuccess={onLoginSuccess} serverConnection={serverConnection} />\n            </Stack>\n        </>\n    )\n}\n","import * as ReactDOM from 'react-dom';\nimport { App } from './components/app';\n\nwindow.addEventListener(\"load\", () => {\n    ReactDOM.render(<App />, document.querySelector(\"#container\"));\n})","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkremote_adb\"] = self[\"webpackChunkremote_adb\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [121], () => (__webpack_require__(1423)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","getPayloadLength","headerBuffer","DataView","getUint32","concatBuffers","b1","b2","tmp","Uint8Array","byteLength","set","buffer","startPullPushLoop","isConnected","pull","push","loggerConfig","payload_length","this","log","tag","direction","error","createDataEventHandler","AWAITING_HEADER","AWAITING_PAYLOAD","state","pending_data","ArrayBuffer","lastPromise","Promise","resolve","handleWriteData","data","slice","boundry","then","AdbTransportProtocolHandler","WebUsbDeviceFilter","classCode","subclassCode","protocolCode","usb","device","type","_connected","_bytesTransferred","up","down","events","EventEmitter","ondisconnect","listener","addListener","handleDisconnect","e","_device","emit","_usb","addEventListener","serialNumber","productName","connect","opened","open","configurations","configuration","interfaces","interface_","alternates","alternate","interfaceSubclass","interfaceClass","interfaceProtocol","configurationValue","selectConfiguration","claimed","claimInterface","interfaceNumber","alternateSetting","selectAlternateInterface","endpoints","endpoint","_inEndpointNumber","endpointNumber","undefined","_outEndpointNumber","Error","write","transferOut","read","length","transferIn","result","status","clearHalt","wsSendOrIgnore","ws","logTag","readyState","OPEN","send","warn","backendWriteOrIgnore","backend","connected","readLoop","CONNECTING","serial","writeLoopCallback","dataEventHandler","event","pipe","onmessage","dispose","removeEventListener","removeAllListeners","close","AdbWebUsbTransport","_connecting","serverConnection","disconnectWebSocket","reject","createWebSocket","binaryType","resolved","onopen","onerror","onclose","catch","disconnectBackend","code","reason","handshakeData","name","JSON","stringify","getRemoteHandshake","serverHandshake","remoteSerial","message","disconnect","bytesTransferred","WebSocket","RemoteAdbDevice","address","updateLoopRunning","lastServerStatusPromise","cookieJar","login","password","fetch","method","headers","body","res","json","monitorServerStatus","callback","on","updateStatusLoop","getServerStatus","fetchServerStatus","setTimeout","_error","serverAddress","window","_fetch","bind","toughCookie","CookieJar","resolveUrl","url","protocol","resolvedUrl","URL","replace","href","init","getCookieString","ServerConnection","connectedDevices","Map","_usbInitialized","isSupported","requestDevice","filters","refreshDevices","createRemoteAdbDevice","d","listenerCount","getDevices","devices","currentDevices","filter","some","iface","map","get","monitorDevices","once","navigator","WebUSB","allowAllDevices","UsbDeviceManager","UsbDeviceManagerSingleton","onWebsocketClose","parse","_logger","console","setGlobalLogger","logger","debug","info","setLogger","useState","setDevices","serverConnectionReady","setServerConnectionReady","localStorage","getItem","autoConnect","setAutoConnect","useEffect","onAutoConnectToggle","useCallback","ev","checked","setItem","toString","style","maxWidth","margin","Stack","tokens","padding","childrenGap","Item","align","Text","variant","color","NeutralColors","gray130","Status","Separator","horizontal","horizontalAlign","verticalAlign","PrimaryButton","text","id","onClick","iconProps","iconName","Toggle","label","inlineLabel","onChange","gray90","Device","Link","isSecureContext","initializeIcons","location","props","setError","isConnecting","setConnecting","connecting","onConnect","resetError","wsUrl","border","borderColor","gray70","Icon","fontSize","fontWeight","grow","Label","DefaultButton","disabled","MessageBar","messageBarType","MessageBarType","isMultiline","onDismiss","dismissButtonAriaLabel","success","userSelect","CommunicationSpeed","time","speedCounterState","setSpeedConunterState","speed","setSpeed","updateSpeed","currentTime","Date","getTime","timeElapsed","Math","floor","interval","setInterval","clearInterval","formatSpeed","b","bytes","format","decimalPlaces","unitSeparator","initialized","setInitialized","statusError","setStatusError","loginSupported","setLoginSupported","loginRequired","setLoginRequired","showLoginDialog","setShowLoginDialog","updateStatus","useMemo","onLoginSuccess","StatusItem","muted","warning","actions","MessageBarButton","ProgressIndicator","LoginDialog","showDialog","setShowDialog","DelayedProgressIndicator","showProgress","setShowProgress","timeout","clearTimeout","loginError","setLoginError","loginSuccess","setLoginSuccess","loginProgress","setLoginProgress","setPassword","hideDialog","dialogDismissed","handlePasswordChanged","target","value","resetLoginError","loginFailed","Dialog","hidden","dialogContentProps","DialogType","normal","title","modalProps","isBlocking","onDismissed","TextField","autoFocus","DialogFooter","rest","styles","root","background","ReactDOM","render","App","document","querySelector","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","O","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","Object","keys","every","key","splice","r","definition","o","defineProperty","enumerable","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","self","forEach","__webpack_exports__"],"sourceRoot":""}